!(function (e, t) { typeof exports === 'object' && typeof module === 'object' ? module.exports = t() : typeof define === 'function' && define.amd ? define([], t) : typeof exports === 'object' ? exports.reduxLogger = t() : e.reduxLogger = t(); }(this, () => (function (e) { function t(n) { if (r[n]) return r[n].exports; const o = r[n] = { exports: {}, id: n, loaded: !1 }; return e[n].call(o.exports, o, o.exports, t), o.loaded = !0, o.exports; } var r = {}; return t.m = e, t.c = r, t.p = '', t(0); }([function (e, t, r) { r(2), e.exports = r(2); }, function (e, t) {
    Object.defineProperty(t, '__esModule', { value: !0 }); const r = t.repeat = function (e, t) { return new Array(t + 1).join(e); }; const n = t.pad = function (e, t) { return r('0', t - e.toString().length) + e; }; t.formatTime = function (e) { return `${n(e.getHours(), 2)}:${n(e.getMinutes(), 2)}:${n(e.getSeconds(), 2)}.${n(e.getMilliseconds(), 3)}`; }, t.timer = typeof performance !== 'undefined' && performance !== null && typeof performance.now === 'function' ? performance : Date;
}, function (e, t, r) {
    function n(e) { return e && e.__esModule ? e : { default: e }; } function o() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = { ...c.default, ...e }; const r = t.logger; const n = t.transformer; const o = t.stateTransformer; const f = t.errorTransformer; const l = t.predicate; const s = t.logErrors; const p = t.diffPredicate; if (typeof r === 'undefined') return function () { return function (e) { return function (t) { return e(t); }; }; }; if (n && console.error("Option 'transformer' is deprecated, use 'stateTransformer' instead!"), e.getState && e.dispatch) return console.error("[redux-logger] redux-logger not installed. Make sure to pass logger instance as middleware:\n\n// Logger with default options\nimport { logger } from 'redux-logger'\nconst store = createStore(\n  reducer,\n  applyMiddleware(logger)\n)\n\n\n// Or you can create your own logger with custom options http://bit.ly/redux-logger-options\nimport createLogger from 'redux-logger'\n\nconst logger = createLogger({\n  // ...options\n});\n\nconst store = createStore(\n  reducer,\n  applyMiddleware(logger)\n)\n"), function () { return function (e) { return function (t) { return e(t); }; }; }; const d = []; return function (e) { const r = e.getState; return function (e) { return function (n) { if (typeof l === 'function' && !l(r, n)) return e(n); const c = {}; d.push(c), c.started = u.timer.now(), c.startedTime = new Date(), c.prevState = o(r()), c.action = n; let h = void 0; if (s) try { h = e(n); } catch (e) { c.error = f(e); } else h = e(n); c.took = u.timer.now() - c.started, c.nextState = o(r()); const g = t.diff && typeof p === 'function' ? p(r, n) : t.diff; if ((0, i.printBuffer)(d, { ...t, diff: g }), d.length = 0, c.error) throw c.error; return h; }; }; }; }Object.defineProperty(t, '__esModule', { value: !0 }), t.logger = t.defaults = void 0; const a = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]); } return e; }; var i = r(3); var u = r(1); const f = r(4); var c = n(f); const l = o(); t.defaults = c.default, t.logger = l, t.default = o;
}, function (e, t, r) {
    function n(e) { return e && e.__esModule ? e : { default: e }; } function o(e) { if (Array.isArray(e)) { for (var t = 0, r = Array(e.length); t < e.length; t++)r[t] = e[t]; return r; } return Array.from(e); } function a(e, t, r, n) { switch (typeof e === 'undefined' ? 'undefined' : f(e)) { case 'object': return typeof e[n] === 'function' ? e[n].apply(e, o(r)) : e[n]; case 'function': return e(t); default: return e; } } function i(e) { const t = e.timestamp; const r = e.duration; return function (e, n, o) { const a = ['action']; return a.push(`%c${String(e.type)}`), t && a.push(`%c@ ${n}`), r && a.push(`%c(in ${o.toFixed(2)} ms)`), a.join(' '); }; } function u(e, t) { const r = t.logger; const n = t.actionTransformer; const o = t.titleFormatter; const u = void 0 === o ? i(t) : o; const f = t.collapsed; const l = t.colors; const p = t.level; const d = t.diff; e.forEach((o, i) => { const h = o.started; const g = o.startedTime; const y = o.action; const v = o.prevState; const b = o.error; let m = o.took; let x = o.nextState; const w = e[i + 1]; w && (x = w.prevState, m = w.started - h); const j = n(y); const S = typeof f === 'function' ? f(() => x, y, o) : f; const k = (0, c.formatTime)(g); const A = l.title ? `color: ${l.title(j)};` : ''; const D = ['color: gray; font-weight: lighter;']; D.push(A), t.timestamp && D.push('color: gray; font-weight: lighter;'), t.duration && D.push('color: gray; font-weight: lighter;'); const O = u(j, k, m); try { S ? l.title ? r.groupCollapsed.apply(r, [`%c ${O}`].concat(D)) : r.groupCollapsed(O) : l.title ? r.group.apply(r, [`%c ${O}`].concat(D)) : r.group(O); } catch (e) { r.log(O); } const E = a(p, j, [v], 'prevState'); const _ = a(p, j, [j], 'action'); const P = a(p, j, [b, v], 'error'); const M = a(p, j, [x], 'nextState'); E && (l.prevState ? r[E]('%c prev state', `color: ${l.prevState(v)}; font-weight: bold`, v) : r[E]('prev state', v)), _ && (l.action ? r[_]('%c action    ', `color: ${l.action(j)}; font-weight: bold`, j) : r[_]('action    ', j)), b && P && (l.error ? r[P]('%c error     ', `color: ${l.error(b, v)}; font-weight: bold;`, b) : r[P]('error     ', b)), M && (l.nextState ? r[M]('%c next state', `color: ${l.nextState(x)}; font-weight: bold`, x) : r[M]('next state', x)), d && (0, s.default)(v, x, r, S); try { r.groupEnd(); } catch (e) { r.log('—— log end ——'); } }); }Object.defineProperty(t, '__esModule', { value: !0 }); var f = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }; t.printBuffer = u; var c = r(1); const l = r(5); var s = n(l);
}, function (e, t) {
    Object.defineProperty(t, '__esModule', { value: !0 }), t.default = {
        level: 'log',
        logger: console,
        logErrors: !0,
        collapsed: void 0,
        predicate: void 0,
        duration: !1,
        timestamp: !0,
        stateTransformer(e) { return e; },
        actionTransformer(e) { return e; },
        errorTransformer(e) { return e; },
        colors: {
            title() { return 'inherit'; }, prevState() { return '#9E9E9E'; }, action() { return '#03A9F4'; }, nextState() { return '#4CAF50'; }, error() { return '#F20404'; }
        },
        diff: !1,
        diffPredicate: void 0,
        transformer: void 0
    }, e.exports = t.default;
}, function (e, t, r) {
    function n(e) { return e && e.__esModule ? e : { default: e }; } function o(e) { if (Array.isArray(e)) { for (var t = 0, r = Array(e.length); t < e.length; t++)r[t] = e[t]; return r; } return Array.from(e); } function a(e) { return `color: ${l[e].color}; font-weight: bold`; } function i(e) { const t = e.kind; const r = e.path; const n = e.lhs; const o = e.rhs; const a = e.index; const i = e.item; switch (t) { case 'E': return [r.join('.'), n, '→', o]; case 'N': return [r.join('.'), o]; case 'D': return [r.join('.')]; case 'A': return [`${r.join('.')}[${a}]`, i]; default: return []; } } function u(e, t, r, n) { const u = (0, c.default)(e, t); try { n ? r.groupCollapsed('diff') : r.group('diff'); } catch (e) { r.log('diff'); }u ? u.forEach((e) => { const t = e.kind; const n = i(e); r.log.apply(r, [`%c ${l[t].text}`, a(t)].concat(o(n))); }) : r.log('—— no diff ——'); try { r.groupEnd(); } catch (e) { r.log('—— diff end —— '); } }Object.defineProperty(t, '__esModule', { value: !0 }), t.default = u; const f = r(6); var c = n(f); var l = {
        E: { color: '#2196F3', text: 'CHANGED:' }, N: { color: '#4CAF50', text: 'ADDED:' }, D: { color: '#F44336', text: 'DELETED:' }, A: { color: '#2196F3', text: 'ARRAY:' }
    }; e.exports = t.default;
}, function (e, t, r) {
    let n; let o; (function (r) {
        !(function (r, a) {
            n = [], o = function () { return a(); }.apply(t, n), !(void 0 !== o && (e.exports = o));
        }(this, (e) => {
            function t(e, t) {
                e.super_ = t, e.prototype = Object.create(t.prototype, {
                    constructor: {
                        value: e, enumerable: !1, writable: !0, configurable: !0
                    }
                });
            } function n(e, t) { Object.defineProperty(this, 'kind', { value: e, enumerable: !0 }), t && t.length && Object.defineProperty(this, 'path', { value: t, enumerable: !0 }); } function o(e, t, r) { o.super_.call(this, 'E', e), Object.defineProperty(this, 'lhs', { value: t, enumerable: !0 }), Object.defineProperty(this, 'rhs', { value: r, enumerable: !0 }); } function a(e, t) { a.super_.call(this, 'N', e), Object.defineProperty(this, 'rhs', { value: t, enumerable: !0 }); } function i(e, t) { i.super_.call(this, 'D', e), Object.defineProperty(this, 'lhs', { value: t, enumerable: !0 }); } function u(e, t, r) { u.super_.call(this, 'A', e), Object.defineProperty(this, 'index', { value: t, enumerable: !0 }), Object.defineProperty(this, 'item', { value: r, enumerable: !0 }); } function f(e, t, r) { const n = e.slice((r || t) + 1 || e.length); return e.length = t < 0 ? e.length + t : t, e.push.apply(e, n), e; } function c(e) { const t = typeof e; return t !== 'object' ? t : e === Math ? 'math' : e === null ? 'null' : Array.isArray(e) ? 'array' : Object.prototype.toString.call(e) === '[object Date]' ? 'date' : typeof e.toString !== 'undefined' && /^\/.*\//.test(e.toString()) ? 'regexp' : 'object'; } function l(t, r, n, s, p, d, h) { p = p || []; const g = p.slice(0); if (typeof d !== 'undefined') { if (s) { if (typeof s === 'function' && s(g, d)) return; if (typeof s === 'object') { if (s.prefilter && s.prefilter(g, d)) return; if (s.normalize) { const y = s.normalize(g, d, t, r); y && (t = y[0], r = y[1]); } } }g.push(d); }c(t) === 'regexp' && c(r) === 'regexp' && (t = t.toString(), r = r.toString()); const v = typeof t; const b = typeof r; if (v === 'undefined')b !== 'undefined' && n(new a(g, r)); else if (b === 'undefined')n(new i(g, t)); else if (c(t) !== c(r))n(new o(g, t, r)); else if (Object.prototype.toString.call(t) === '[object Date]' && Object.prototype.toString.call(r) === '[object Date]' && t - r !== 0)n(new o(g, t, r)); else if (v === 'object' && t !== null && r !== null) { if (h = h || [], h.indexOf(t) < 0) { if (h.push(t), Array.isArray(t)) { let m; t.length; for (m = 0; m < t.length; m++)m >= r.length ? n(new u(g, m, new i(e, t[m]))) : l(t[m], r[m], n, s, g, m, h); for (;m < r.length;)n(new u(g, m, new a(e, r[m++]))); } else { const x = Object.keys(t); let w = Object.keys(r); x.forEach((o, a) => { const i = w.indexOf(o); i >= 0 ? (l(t[o], r[o], n, s, g, o, h), w = f(w, i)) : l(t[o], e, n, s, g, o, h); }), w.forEach((t) => { l(e, r[t], n, s, g, t, h); }); }h.length -= 1; } } else t !== r && (v === 'number' && isNaN(t) && isNaN(r) || n(new o(g, t, r))); } function s(t, r, n, o) { return o = o || [], l(t, r, (e) => { e && o.push(e); }, n), o.length ? o : e; } function p(e, t, r) { if (r.path && r.path.length) { let n; let o = e[t]; const a = r.path.length - 1; for (n = 0; n < a; n++)o = o[r.path[n]]; switch (r.kind) { case 'A': p(o[r.path[n]], r.index, r.item); break; case 'D': delete o[r.path[n]]; break; case 'E': case 'N': o[r.path[n]] = r.rhs; } } else switch (r.kind) { case 'A': p(e[t], r.index, r.item); break; case 'D': e = f(e, t); break; case 'E': case 'N': e[t] = r.rhs; } return e; } function d(e, t, r) { if (e && t && r && r.kind) { for (var n = e, o = -1, a = r.path ? r.path.length - 1 : 0; ++o < a;) typeof n[r.path[o]] === 'undefined' && (n[r.path[o]] = typeof r.path[o] === 'number' ? [] : {}), n = n[r.path[o]]; switch (r.kind) { case 'A': p(r.path ? n[r.path[o]] : n, r.index, r.item); break; case 'D': delete n[r.path[o]]; break; case 'E': case 'N': n[r.path[o]] = r.rhs; } } } function h(e, t, r) { if (r.path && r.path.length) { let n; let o = e[t]; const a = r.path.length - 1; for (n = 0; n < a; n++)o = o[r.path[n]]; switch (r.kind) { case 'A': h(o[r.path[n]], r.index, r.item); break; case 'D': o[r.path[n]] = r.lhs; break; case 'E': o[r.path[n]] = r.lhs; break; case 'N': delete o[r.path[n]]; } } else switch (r.kind) { case 'A': h(e[t], r.index, r.item); break; case 'D': e[t] = r.lhs; break; case 'E': e[t] = r.lhs; break; case 'N': e = f(e, t); } return e; } function g(e, t, r) { if (e && t && r && r.kind) { let n; let o; let a = e; for (o = r.path.length - 1, n = 0; n < o; n++) typeof a[r.path[n]] === 'undefined' && (a[r.path[n]] = {}), a = a[r.path[n]]; switch (r.kind) { case 'A': h(a[r.path[n]], r.index, r.item); break; case 'D': a[r.path[n]] = r.lhs; break; case 'E': a[r.path[n]] = r.lhs; break; case 'N': delete a[r.path[n]]; } } } function y(e, t, r) { if (e && t) { const n = function (n) { r && !r(e, t, n) || d(e, t, n); }; l(e, t, n); } } let v; let b; let m = []; return v = typeof r === 'object' && r ? r : typeof window !== 'undefined' ? window : {}, b = v.DeepDiff, b && m.push(() => { typeof b !== 'undefined' && v.DeepDiff === s && (v.DeepDiff = b, b = e); }), t(o, n), t(a, n), t(i, n), t(u, n), Object.defineProperties(s, {
                diff: { value: s, enumerable: !0 }, observableDiff: { value: l, enumerable: !0 }, applyDiff: { value: y, enumerable: !0 }, applyChange: { value: d, enumerable: !0 }, revertChange: { value: g, enumerable: !0 }, isConflict: { value() { return typeof b !== 'undefined'; }, enumerable: !0 }, noConflict: { value() { return m && (m.forEach((e) => { e(); }), m = null), s; }, enumerable: !0 }
            }), s;
        }));
    }).call(t, (function () { return this; }()));
}]))));
